# Assessment Bot - Backend

This repository contains the backend code for the Assessment Bot, which is responsible for managing assessments, grading, and providing feedback. It is written in TypeScript and uses Node.js as the runtime environment. 

There is no front end, and is accessible via a REST API only. Configuration values are stored in environment variables, and prompt templates are stored as markdown files. It is designed to be stateless, meaning that it does not store any user data or session information on the server.

It will start initially as a monolithic application that will be run in a minimal Docker container, ensuring cloud agnosticism. If the project expands, the goal should be a collection of microservices that can initially be coordinated via a single Docker Compose file, and later orchestrated with Kubernetes.

## Guiding Principles

1. **Security**: Always prioritise security in your code. Validate inputs, sanitise outputs, and handle sensitive data with care. This includes using environment variables for configuration and secrets, and ensuring that any user-generated content is properly escaped to prevent XSS attacks.
2. **Emphemerality**: Design the system to be stateless. Assessment Bot pritorises privacy above all else. No student PII is should even be sent to the backend. Maintaining statelessness ensures that any inadvertant data leaks persist only as long as the request is being processed.
3. **Performance**: Write efficient code that minimises resource usage. Use asynchronous programming patterns to handle I/O operations without blocking the event loop.
4. **Perfer well-maintained libraries**: Avoid reinventing the wheel. Use well-maintained libraries and frameworks that are widely adopted in the Node.js ecosystem. This includes libraries for routing, database access, and validation.
4. **Modularity**: Structure the code in a modular way to promote reusability and maintainability. Use TypeScript interfaces and types to define clear contracts for modules.
5. **TDD**: Write tests for your code. Use a test framework like Jest or Mocha to ensure that your code is reliable and maintainable. Write unit tests for individual functions and integration tests for the overall system.
6. **Strong Obejct-Oriented Design**: Use object-oriented design principles to create a clean and maintainable codebase. This includes using classes, interfaces, and inheritance where appropriate. 
    a. **Refactor to avoid God Objects**: Avoid creating "God Objects" that have too many responsibilities. Instead, break down complex objects into smaller, more manageable components.
    b. **SOLID**: Follow the SOLID principles.
7. **Documentation**: Write clear and concise documentation for your code. Use JSDoc comments to document functions, classes, and modules. Provide examples of how to use the code and explain any complex logic.

## Stack

- **Docker**: Use base image `node:20-alpine` for a minimal and efficient container.
- **Node.js**: The runtime environment for the backend code.
- **TypeScript**: The programming language used for the backend code, providing static typing and modern JavaScript features.
- **Passport.js**: For handling authentication strategies (e.g., API Keys via `passport-http-bearer`).
- **NestJS**: The core web framework. It is a progressive Node.js framework for building efficient, reliable and scalable server-side applications. It strongly aligns with the OOP and SOLID principles outlined above.
- **Zod**: A TypeScript-first schema declaration and validation library. It's essential for fulfilling the security principle of validating all inputs.
- **Jest**: The testing framework. An all-in-one framework that simplifies the TDD process mentioned in the guiding principles.
- **json-repair**: A library to fix malformed JSON strings, making LLM responses more robust.

## Expected Data Flow

1. Request comes in via the REST API. Contains Auth Token (API Key in the header) and a JSON body with reference task, template task and student response.
2. Request is validated using Zod schemas.
3. If the request is valid, it is authenticated using Passport.js.
4. The request is handled by a NestJS `Controller`, which delegates the core logic to an appropriate `AssessorService` (e.g., for text, tables, or images).
5. A prompt object is generated using the reference, template and student reponse.
6. The prompt is sent to an LLMService superclass, which handles the interaction with the the chosen LLM. Each LLM (e.g. OpenAI, Anthropic) will have its own subclass that implements the specific API calls.
7. The LLM processes the prompt and returns a raw string response.
8. The raw response is passed through a resilient parsing mechanism. First, it attempts a standard `JSON.parse()`. If that fails, it uses `json-repair` to fix common syntax errors before attempting to parse again.
9. The repaired and parsed JSON object is validated against a Zod schema to ensure it conforms to the expected structure.
10. The validated response is processed by the `AssessorService`, which cleans the data and formats it for the client.
11. The final response is returned to the client via the REST API.