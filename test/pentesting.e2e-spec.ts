import * as path from 'path';

import request from 'supertest';

import { startApp, stopApp, AppInstance } from './utils/app-lifecycle';
import { waitForLog } from './utils/log-watcher';

describe('Penetration Testing (e2e)', () => {
  let app: AppInstance;
  const logFilePath = path.join(__dirname, 'logs', 'pentesting.e2e-spec.log');

  beforeEach(async () => {
    app = await startApp(logFilePath);
  });

  afterEach(() => {
    stopApp(app.appProcess);
  });

  // --- Advanced Penetration Test Cases ---
  it('should reject advanced prototype pollution attempts', async () => {
    const payload = {
      taskType: 'TEXT',
      reference: 'test',
      template: 'test',
      studentResponse: 'test',
      constructor: { prototype: { isAdmin: true } },
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Validation failed');
  });

  it('should reject advanced NoSQL injection attempts', async () => {
    const payload = {
      taskType: 'TEXT',
      reference: { $ne: null, $regex: '.*' },
      template: 'test',
      studentResponse: 'test',
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Validation failed');
    // Check for either error message variant in any error object
    const errorMessages = (res.body.errors || []).map((e) => e.message || e);
    const found = errorMessages.some(
      (msg) =>
        typeof msg === 'string' &&
        (msg.includes('Expected string, received object') ||
          msg.includes('Invalid input: expected string, received object')),
    );
    expect(found).toBe(true);
  });

  it('should reject IMAGE task with mixed Buffer/string types', async () => {
    const payload = {
      taskType: 'IMAGE',
      reference: { type: 'Buffer', data: [1, 2, 3] },
      template: 'data:image/png;base64,valid',
      studentResponse: 'data:image/png;base64,valid',
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Validation failed');
    expect(JSON.stringify(res.body.errors)).toContain('Invalid input');
  });

  it('should reject IMAGE task with Buffer-like string', async () => {
    const payload = {
      taskType: 'IMAGE',
      reference: '[object Object]',
      template: 'data:image/png;base64,valid',
      studentResponse: 'data:image/png;base64,valid',
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Invalid base64 string format.');
  });

  it('should not allow CORS from arbitrary origins', async () => {
    const res = await request(app.appUrl)
      .options('/v1/assessor')
      .set('Origin', 'https://evil.com')
      .set('Access-Control-Request-Method', 'POST')
      .expect(204);
    // Should not reflect the origin or allow all
    expect(res.headers['access-control-allow-origin']).not.toBe(
      'https://evil.com',
    );
  });

  it('should not leak detailed error messages in production', async () => {
    // Simulate production by setting NODE_ENV
    process.env.NODE_ENV = 'production';
    const invalidPayload = { taskType: 'INVALID' };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(invalidPayload)
      .expect(400);
    // In production, only the generic error message should be shown
    expect(res.body.message).toBe('Validation failed');
    // Reset NODE_ENV
    process.env.NODE_ENV = '';
  });

  describe('Authentication and Authorization Bypass', () => {
    const validPayload = {
      taskType: 'TEXT',
      reference: 'test',
      template: 'test',
      studentResponse: 'test',
    };

    it('should reject requests with a malformed Bearer scheme and log a warning', async () => {
      // Test with lowercase 'bearer'
      const res1 = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', 'bearer ' + app.apiKey)
        .send(validPayload)
        .expect(401);

      // The primary assertion is that the log is found. Adding a dummy expect to satisfy the linter.
      expect(res1.status).toBe(401);

      await waitForLog(logFilePath, (log) => {
        return log.level === 40 && log.msg?.includes('Malformed Bearer');
      });

      // Test with no space after 'Bearer'
      const res2 = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', 'Bearer' + app.apiKey)
        .send(validPayload)
        .expect(401);

      expect(res2.status).toBe(401);

      await waitForLog(logFilePath, (log) => {
        return log.level === 40 && log.msg?.includes('Malformed Bearer scheme');
      });
    });

    it('should reject requests with API key in query parameters', async () => {
      expect.hasAssertions();
      await request(app.appUrl)
        .post(`/v1/assessor?api_key=${app.apiKey}`)
        .send(validPayload)
        .expect(401);
    });

    it('should reject requests with API key in the body', async () => {
      expect.hasAssertions();
      const payloadWithKey = { ...validPayload, apiKey: app.apiKey };
      await request(app.appUrl)
        .post('/v1/assessor')
        .send(payloadWithKey)
        .expect(401);
    });
  });

  describe('Input Validation and Denial of Service', () => {
    it('should handle prototype pollution attempts gracefully', async () => {
      const maliciousPayload = {
        taskType: 'TEXT',
        reference: 'test',
        template: 'test',
        studentResponse: 'test',
        __proto__: { isAdmin: true },
      };

      // Expect a 201, as the underlying parser strips __proto__.
      // The test now verifies that the pollution does NOT propagate.
      await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(maliciousPayload)
        .expect(201);

      let renderLog: LogObject | undefined;
      // Verify that the polluted property does not appear in the prompt's keys.
      await waitForLog(logFilePath, (log) => {
        if (log.msg?.startsWith('Render called. this keys:')) {
          renderLog = log;
          return true;
        }
        return false;
      });

      expect(renderLog).toBeDefined();
      expect(renderLog?.msg).not.toContain('isAdmin');
    });

    it('should handle deeply nested JSON without crashing (DoS)', async () => {
      type NestedObject = { [key: string]: NestedObject };
      let nested: NestedObject = {};
      let current = nested;
      // Create a deeply nested object to test parser stack limits.
      for (let i = 0; i < 2000; i++) {
        current.a = {};
        current = current.a;
      }
      const payload = {
        taskType: 'TEXT',
        reference: 'test',
        template: 'test',
        studentResponse: nested,
      };

      // Expect a 400 from Zod validation, not a server crash (500).
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(400);

      expect(res.body.message).toBe('Validation failed');
    }, 30000);

    it('should not be vulnerable to ReDoS on data URI validation', async () => {
      // This string is designed to be "almost" a valid data URI, but fails at the end.
      // A vulnerable regex might take a very long time to process this.
      // The string is long to amplify the effect of any potential backtracking.
      const maliciousDataUri =
        'data:image/png;base64,' + 'a'.repeat(50000) + '!';

      const payload = {
        taskType: 'IMAGE',
        reference: maliciousDataUri,
        template: 'data:image/png;base64,valid',
        studentResponse: 'data:image/png;base64,valid',
      };

      // We expect a 400 Bad Request due to validation failure.
      // A timeout or a 500 error would indicate a ReDoS vulnerability.
      // The test timeout (default 5s) will catch long-running regex evaluation.
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(400);

      expect(res.body.message).toBe('Invalid base64 string format.');
    }, 10000); // Set a generous timeout, but not too long.

    it('should reject payloads with NoSQL injection attempts', async () => {
      const nosqlInjectionPayload = {
        taskType: 'TEXT',
        reference: { $gt: '' }, // Using a MongoDB operator
        template: 'test',
        studentResponse: 'test',
      };

      // Zod should reject this as 'reference' is not a string.
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(nosqlInjectionPayload)
        .expect(400);

      expect(res.body.message).toBe('Validation failed');
      expect(JSON.stringify(res.body.errors)).toContain(
        'Expected string, received object',
      );
    });

    it('should handle massive string payloads without crashing (DoS)', async () => {
      expect.hasAssertions();
      // 50MB string to test memory limits.
      // The default body-parser limit in NestJS is 100kb, so this should be rejected.
      const largeString = 'a'.repeat(50 * 1024 * 1024);
      const payload = {
        taskType: 'TEXT',
        reference: largeString,
        template: 'test',
        studentResponse: 'test',
      };

      // Expect a 413 Payload Too Large. A 500 would indicate poor error handling.
      await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(413);
    }, 30000);
  });

  describe('Information Disclosure', () => {
    it('should not leak stack traces on validation error', async () => {
      const invalidPayload = { taskType: 'INVALID' };
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(invalidPayload)
        .expect(400);

      expect(res.body).toHaveProperty('message', 'Validation failed');
      expect(res.body).not.toHaveProperty('stack');
    });

    it('should handle path traversal attempts safely', async () => {
      expect.hasAssertions();
      await request(app.appUrl)
        .get('/v1/assessor/..%2f..%2fetc/passwd')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .expect(404);
    });
  });

  describe('Business Logic Exploits', () => {
    it('should reject IMAGE task with a non-image data URI', async () => {
      const payload = {
        taskType: 'IMAGE',
        reference: 'data:application/pdf;base64,JVBERi0xLjQKJ...',
        template: 'data:application/pdf;base64,JVBERi0xLjQKJ...',
        studentResponse: 'data:application/pdf;base64,JVBERi0xLjQKJ...',
      };

      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(400);

      expect(res.body.message).toBe('Invalid base64 image format.');
    });
  });
});
