import { ChildProcessWithoutNullStreams } from 'child_process';

import request from 'supertest';

import { startApp, stopApp, AppInstance } from './utils/app-lifecycle';

describe('Penetration Testing (e2e)', () => {
  let app: AppInstance;
  const logFilePath = '/tmp/pentest.log';

  beforeEach(async () => {
    app = await startApp(logFilePath);
  });

  afterEach(() => {
    stopApp(app.appProcess);
  });

  // --- Advanced Penetration Test Cases ---
  it('should reject advanced prototype pollution attempts', async () => {
    const payload = {
      taskType: 'TEXT',
      reference: 'test',
      template: 'test',
      studentResponse: 'test',
      constructor: { prototype: { isAdmin: true } },
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Validation failed');
  });

  it('should reject advanced NoSQL injection attempts', async () => {
    const payload = {
      taskType: 'TEXT',
      reference: { $ne: null, $regex: '.*' },
      template: 'test',
      studentResponse: 'test',
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Validation failed');
    expect(JSON.stringify(res.body.errors)).toContain(
      'Expected string, received object',
    );
  });

  it('should reject IMAGE task with mixed Buffer/string types', async () => {
    const payload = {
      taskType: 'IMAGE',
      reference: { type: 'Buffer', data: [1, 2, 3] },
      template: 'data:image/png;base64,valid',
      studentResponse: 'data:image/png;base64,valid',
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Validation failed');
    expect(JSON.stringify(res.body.errors)).toContain('Invalid input');
  });

  it('should reject IMAGE task with Buffer-like string', async () => {
    const payload = {
      taskType: 'IMAGE',
      reference: '[object Object]',
      template: 'data:image/png;base64,valid',
      studentResponse: 'data:image/png;base64,valid',
    };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(payload)
      .expect(400);
    expect(res.body.message).toBe('Invalid base64 string format.');
  });

  it('should not allow CORS from arbitrary origins', async () => {
    const res = await request(app.appUrl)
      .options('/v1/assessor')
      .set('Origin', 'https://evil.com')
      .set('Access-Control-Request-Method', 'POST')
      .expect(204);
    // Should not reflect the origin or allow all
    expect(res.headers['access-control-allow-origin']).not.toBe(
      'https://evil.com',
    );
  });

  it('should not leak detailed error messages in production', async () => {
    // Simulate production by setting NODE_ENV
    process.env.NODE_ENV = 'production';
    const invalidPayload = { taskType: 'INVALID' };
    const res = await request(app.appUrl)
      .post('/v1/assessor')
      .set('Authorization', `Bearer ${app.apiKey}`)
      .send(invalidPayload)
      .expect(400);
    expect(res.body.errors[0].message).toBe(
      "Invalid discriminator value. Expected 'TEXT' | 'TABLE' | 'IMAGE'",
    );
    // Reset NODE_ENV
    process.env.NODE_ENV = '';
  });

  describe('Authentication and Authorization Bypass', () => {
    const validPayload = {
      taskType: 'TEXT',
      reference: 'test',
      template: 'test',
      studentResponse: 'test',
    };

    it('should reject requests with a malformed Bearer scheme', async () => {
      await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', 'bearer ' + apiKey) // lowercase 'bearer'
        .send(validPayload)
        .expect(401);

      await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', 'Bearer' + apiKey) // no space
        .send(validPayload)
        .expect(401);
    });

    it('should reject requests with API key in query parameters', async () => {
      await request(app.appUrl)
        .post(`/v1/assessor?api_key=${apiKey}`)
        .send(validPayload)
        .expect(401);
    });

    it('should reject requests with API key in the body', async () => {
      const payloadWithKey = { ...validPayload, apiKey };
      await request(app.appUrl)
        .post('/v1/assessor')
        .send(payloadWithKey)
        .expect(401);
    });
  });

  describe('Input Validation and Denial of Service', () => {
    it('should handle prototype pollution attempts gracefully', async () => {
      const maliciousPayload = {
        taskType: 'TEXT',
        reference: 'test',
        template: 'test',
        studentResponse: 'test',
        __proto__: { isAdmin: true },
      };

      // A 400 Bad Request is the expected outcome due to Zod validation.
      // A server crash or unexpected success would indicate a vulnerability.
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(maliciousPayload)
        .expect(400);

      expect(res.body.message).toBe('Validation failed');
    });

    it('should handle deeply nested JSON without crashing (DoS)', async () => {
      type NestedObject = { [key: string]: NestedObject };
      let nested: NestedObject = {};
      let current = nested;
      // Create a deeply nested object to test parser stack limits.
      for (let i = 0; i < 2000; i++) {
        current.a = {};
        current = current.a;
      }
      const payload = {
        taskType: 'TEXT',
        reference: 'test',
        template: 'test',
        studentResponse: nested,
      };

      // Expect a 400 from Zod validation, not a server crash (500).
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(400);

      expect(res.body.message).toBe('Validation failed');
    }, 30000);

    it('should not be vulnerable to ReDoS on data URI validation', async () => {
      // This string is designed to be "almost" a valid data URI, but fails at the end.
      // A vulnerable regex might take a very long time to process this.
      // The string is long to amplify the effect of any potential backtracking.
      const maliciousDataUri =
        'data:image/png;base64,' + 'a'.repeat(50000) + '!';

      const payload = {
        taskType: 'IMAGE',
        reference: maliciousDataUri,
        template: 'data:image/png;base64,valid',
        studentResponse: 'data:image/png;base64,valid',
      };

      // We expect a 400 Bad Request due to validation failure.
      // A timeout or a 500 error would indicate a ReDoS vulnerability.
      // The test timeout (default 5s) will catch long-running regex evaluation.
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(400);

      expect(res.body.message).toBe('Invalid base64 string format.');
    }, 10000); // Set a generous timeout, but not too long.

    it('should reject payloads with NoSQL injection attempts', async () => {
      const nosqlInjectionPayload = {
        taskType: 'TEXT',
        reference: { $gt: '' }, // Using a MongoDB operator
        template: 'test',
        studentResponse: 'test',
      };

      // Zod should reject this as 'reference' is not a string.
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(nosqlInjectionPayload)
        .expect(400);

      expect(res.body.message).toBe('Validation failed');
      expect(JSON.stringify(res.body.errors)).toContain(
        'Expected string, received object',
      );
    });

    it('should handle massive string payloads without crashing (DoS)', async () => {
      // 50MB string to test memory limits.
      // The default body-parser limit in NestJS is 100kb, so this should be rejected.
      const largeString = 'a'.repeat(50 * 1024 * 1024);
      const payload = {
        taskType: 'TEXT',
        reference: largeString,
        template: 'test',
        studentResponse: 'test',
      };

      // Expect a 413 Payload Too Large. A 500 would indicate poor error handling.
      await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(413);
    }, 30000);
  });

  describe('Information Disclosure', () => {
    it('should not leak stack traces on validation error', async () => {
      const invalidPayload = { taskType: 'INVALID' };
      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(invalidPayload)
        .expect(400);

      expect(res.body).toHaveProperty('message', 'Validation failed');
      expect(res.body).not.toHaveProperty('stack');
    });

    it('should handle path traversal attempts safely', async () => {
      await request(app.appUrl)
        .get('/v1/assessor/..%2f..%2fetc/passwd')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .expect(404);
    });
  });

  describe('Business Logic Exploits', () => {
    it('should reject IMAGE task with a non-image data URI', async () => {
      const payload = {
        taskType: 'IMAGE',
        reference: 'data:application/pdf;base64,JVBERi0xLjQKJ...',
        template: 'data:application/pdf;base64,JVBERi0xLjQKJ...',
        studentResponse: 'data:application/pdf;base64,JVBERi0xLjQKJ...',
      };

      const res = await request(app.appUrl)
        .post('/v1/assessor')
        .set('Authorization', `Bearer ${app.apiKey}`)
        .send(payload)
        .expect(400);

      expect(res.body.message).toBe('Invalid base64 image format.');
    });
  });
});
